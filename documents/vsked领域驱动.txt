

领域驱动设计应当是与技术架构无关的，里面的业务不应当依赖于技术架构，比如spring的注入。
html,js,css分离的
代码与数据应当是分离的，代码里不应当出现sql脚本
代码与配置应当是分享的，配置不应当写在代码中，这样变更会复杂

领域模型不应当只有属性，需要有丰富的行为
应当面向接口编程
读写应当使用不同模式来进行如CQRS


在某些情况下，最清楚、最实用的设计会包含一些特殊的操作，这些操作从概念上讲不属于任何对象。与其把它们强制地归于哪一类，不如顺其自然地在模型中引入一种新的元素，这就是Service（服务)。



领域
子域
核心域
通用域
支撑域



聚合根
实体
值对象


模块
模块内组织结构
领域对象，领域服务，领域资源库，防腐层

目录结构
com
└─company
    └─team
        └─bussiness
            ├─domain   领域相关
            │  ├─model  领域模型相关
            │  │  ├─aggregate 聚合根
            │  │  ├─entity 实体
            │  │  └─valobj 值对象
            │  ├─repo 资源库
            │  └─service 聚合根服务
            ├─facade 防腐层
            ├─service 领域服务
            ├─utils 工具类
            └─web
--------------------------------------------------------------------------------
[0] DDD领域驱动设计（三） 之 聚合（根）、实体、值对象
1.      聚合根、实体、值对象的区别？
从标识的角度：
聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识，不存在这个值对象或那个值对象的说法；

从是否只读的角度：
聚合根除了唯一标识外，其他所有状态信息都理论上可变；实体是可变的；值对象是只读的；

从生命周期的角度：
聚合根有独立的生命周期，实体的生命周期从属于其所属的聚合，实体完全由其所属的聚合根负责管理维护；值对象无生命周期可言，因为只是一个值；

2.      聚合根、实体、值对象对象之间如何建立关联？

聚合根到聚合根：通过ID关联；
聚合根到其内部的实体，直接对象引用；
聚合根到值对象，直接对象引用；
实体对其他对象的引用规则：
1）能引用其所属聚合内的聚合根、实体、值对象；
2）能引用外部聚合根，但推荐以ID的方式关联，另外也可以关联某个外部聚合内的实体，但必须是ID关联，
否则就出现同一个实体的引用被两个聚合根持有，这是不允许的，一个实体的引用只能被其所属的聚合根持有；

值对象对其他对象的引用规则：只需确保值对象是只读的即可，推荐值对象的所有属性都尽量是值对象；

3.      如何识别聚合与聚合根？

明确含义：一个Bounded Context（界定的上下文）可能包含多个聚合，每个聚合都有一个根实体，叫做聚合根；
识别顺序：先找出哪些实体可能是聚合根，再逐个分析每个聚合根的边界，即该聚合根应该聚合哪些实体或值对象；最后再划分Bounded Context；
聚合边界确定法则：根据不变性约束规则（Invariant）。不变性规则有两类：
1）聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合；
2）聚合内的某些对象的状态必须满足某个业务规则；
 

例子分析1：订单模型

Order（一 个订单）必须有对应的客户信息，否则就不能称为一个有效的Order；同理，Order对OrderLineItem有不变性约束，
Order也必须至少有一个OrderLineItem(一条订单明细)，否 则就不能称为一个有效的Order；
另外，Order中的任何OrderLineItem的数量都不能为0，否则认为该OrderLineItem是无效 的，同时可以推理出Order也可能是无效的。
因为如果允许一个OrderLineItem的数量为0的话，就意味着可能会出现所有 OrderLineItem的数量都为0，这就导致整个Order的总价为0，
这是没有任何意义的，是不允许的，从而导致Order无效；所以，必须要求 Order中所有的OrderLineItem的数量都不能为0；
那么现在可以确定的是Order必须包含一些OrderLineItem，那么应该是通 过引用的方式还是ID关联的方式来表达这种包含关系呢？
这就需要引出另外一个问题，那就是先要分析出是OrderLineItem是否是一个独立的聚合 根。
回答了这个问题，那么根据上面的规则就知道应该用对象引用还是用ID关联了。那么OrderLineItem是否是一个独立的聚合根呢？
因为聚合根意 味着是某个聚合的根，而聚合有代表着某个上下文边界，而一个上下文边界又代表着某个独立的业务场景，
这个业务场景操作的唯一对象总是该上下文边界内的聚合 根。想到这里，我们就可以想想，
有没有什么场景是会绕开订单直接对某个订单明细进行操作的。也就是在这种情况下，我们 是以OrderLineItem为主体，
完全是在面向OrderLineItem在做业务操作。有这种业务场景吗？没有，我们对 OrderLineItem的所有的操作都是以Order为出发点，
我们总是会面向整个Order在做业务操作，比如向Order中增加明细，修改 Order的某个明细对应的商品的购买数量，
从Order中移除某个明细，等等类似操作，我们从来不会从OrderlineItem为出发点去执行一些业 务操作；
另外，从生命周期的角度去理解，那么OrderLineItem离开Order没有任何存在的意义，也就是说OrderLineItem的生命周 期是从属于Order的。
所以，我们可以很确信的回答，OrderLineItem是一个实体。

 

例子分析2：帖子与回复的模型，做个对比，以便更好地理解。

不 变性分析：帖子和回复之间有不变性规则吗？似乎我们只知道一点是肯定的，那就是帖子和回复之间的关系，
1：N的关系；除了这个之外，我们看不到任何其他的 不变性规则。那么这个1：N的对象关系是一种不变性规则吗？
不是！首先，一个帖子可以没有任何回复，帖子也不对它的回复有任何规则约束，它甚至都不知道自 己有多少个回复；
再次，发表了一个回复和帖子也没有任何关系；其次，发表回复对帖子没有任何改变；从业务场景的角度去分析，
我们有发表帖子的场景，有发表 回复的场景。当在发表回复的时候，是以回复为主体的，帖子只是这个回复里所包含的必要信息，
用于说明这个回复是对哪个帖子的回复。这些都说明帖子和回复之 间找不出任何不变性约束的规则；因为帖子和回复都有各自独立的业务场景的需要，
所以可以很容易理解它们都是独立的聚合根；那也很容易知道该如何建立他们之 间的关联了，
但是我们要尽量减少关联，所以只保留回复对帖子的关联即可；
帖子没有任何必要去保存一个回复的ID的列表；那么你可能会说，当我删除一个帖子 后，回复应该是没有存在的意义的呀？
不对，不是没有存在的意义，而是删除了帖子后导致了回复对帖子的关联信息的缺失，导致数据不一致。
这是因为帖子和回复 之间有一种必然的联系（1：N），回复一定会有一个对应的帖子；
但是回复有其自己的生命周期，不应该随着帖子的删除而级联删除。这种情况下，如果你删除了 帖子，就导致回复也成为了一条无效的数据；
所以，我们绝对不允许删除任何聚合根，因为一旦你删除了聚合根，那就意味着与该聚合根相关的其他任何聚合根都会 有外键引用缺失的问题，
会导致整个领域模型数据的不一致；所以，永远都不要删除聚合根；

领域模型：聚合、聚合根
聚合
聚合Aggregate就是一组相关对象的集合，我们把它作为数据修改和访问的单元。一个聚合包含聚合根、实体和值对象。

每个聚合都会有一个聚合根和聚合的边界Boundary，边界定义了在一个聚合里面内部应该有哪些实体，哪些子实体对象。定义边界的原因是我们期望对一个聚合的访问是通过聚合根点进行的，聚合里面的子实体对外界是完全封闭的。对于外部对象不应该去访问到一个聚合边界里面的子实体。

按实际对象分析思路，在领域模型中的领域对象分析应该按照从顶向下的思路进行展开，如果这样的话首先识别到的就是聚合根对象，然后再考虑对聚合根对象进行展开，在聚合根对象的展开过程中进一步细化子实体之间的关联和依赖关系。

实体、聚合根和值对象
实体有ID标识，有生命周期，有状态（用值对象来描述状态），实体通过ID进行区分。

聚合根是实体，聚合根的ID全局唯一标识。聚合根下面的实体的ID在聚合根内唯一即可。
聚合根相当于主Entity，子实体都不可能孤立存在，它们必须依附于一个聚合根存在。

值对象的核心本质是值，与是否有复杂类型无关，值对象没有生命周期，通过两个值对象的值是否相同区分是否是同一个值对象，值对象主要用于描述实体的状态。

实体
具有唯一标识
持久化
具有生命周期
通过ID判断相等性
可变

值对象
无唯一标识
用完就丢，主要起描述性作用
通过属性判断相等性，实现Equals方法
不可变

聚合设计的原则
聚合是用来封装真正的不变性，而不是简单的将对象组合在一起
聚合应尽量设计的小，主要因为业务决定聚合，业务改变聚合，尽可能小的拆分，可以避免重构，重新拆分
聚合之间的关联通过ID，而不是对象引用
聚合内强一致性，聚合之间最终一致性（高内聚低耦合）。边界就是界限上下文。
链接
领域模型：聚合、聚合根详解
领域模型核心概念：实体、值对象和聚合根
领域驱动设计： 构建你的代码蓝图
Domain-driven Design - Overview and building blocks

作者：杰森斯坦sen
链接：https://www.jianshu.com/p/7f3d739377bf
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。